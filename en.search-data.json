{"/about/":{"data":{"":"","architecture#Architecture":"The compilation pipeline has four stages:\nSource → Reader → Expander → Compiler → VM Reader — parses text into S-expressions with source locations Expander — hygienic macro expansion (syntax-rules, define-record-type, guard, quasiquote) Compiler — compiles expanded syntax to bytecode (12 instructions) VM — a stack-based accumulator machine that executes bytecode The VM supports first-class continuations (stack-copying call/cc), dynamic-wind, and guaranteed tail-call optimization.","design-philosophy#Design philosophy":"Compilation only. There is no interpreter. Even interactive REPL input is compiled to bytecode before execution. This keeps the execution model uniform and means optimizations benefit all code paths.\nR7RS first. Bilk Scheme implements the full R7RS standard including all 16 (scheme ...) libraries, the library system (define-library, import, export), hygienic macros, and first-class continuations.\nBatteries included. 36 bundled SRFIs, a full numeric tower (fixnum through complex), and developer tools (LSP, DAP, profiler) ship with the compiler.\nEmbeddable. Multiple independent Scheme instances can coexist in a single process. Embedding APIs are provided for both OCaml and C.","implementation#Implementation":"Bilk Scheme is implemented in OCaml (37 modules, ~21k lines) with a test suite of 1600+ tests across 40 test files. It requires OCaml 5.3.0 with the BER MetaOCaml variant and uses GMP (via zarith) for arbitrary-precision arithmetic.\nThe 12 bytecode instructions are: Halt, Const, Lookup, Define, SetBang, Push, Jump, JumpFalse, Call, TailCall, Return, and MakeClosure.","license#License":"Bilk Scheme is released under the MIT License.","source-code#Source code":"The source is hosted on GitHub: github.com/bilk-scheme/bilk","what-is-bilk-scheme#What is Bilk Scheme?":"Bilk Scheme is an R7RS Scheme implementation written in OCaml. It compiles Scheme source to bytecode and executes it on a stack-based virtual machine — there is no interpreter mode. Every eval compiles to bytecode first, then executes.\nBilk Scheme aims to be a modern, batteries-included Scheme with the developer tools you’d expect from a mainstream language: an LSP server, a debugger, a profiler, a package manager, and an interactive REPL with syntax highlighting and structural editing."},"title":"About Bilk Scheme"},"/contributing/":{"data":{"":"Contributions to Bilk Scheme are welcome. Here’s how to get involved.","code-conventions#Code conventions":"Every .ml module in lib/ has a corresponding .mli interface file Depend on interfaces, not implementation details Favor small functions — each should do one thing Keep solutions simple and readable; three clear lines beat one opaque line Nontrivial optimizations require evidence (benchmarks) before acceptance","development-practices#Development practices":"Bilk Scheme follows strict test-driven development (red-green-refactor):\nWrite a failing test that demonstrates the bug or specifies the new behavior Write the minimum code to make the test pass Refactor with confidence, keeping tests green The test suite uses Alcotest for example-based tests and QCheck for property-based tests. Property tests are preferred for capturing invariants (round-trips, algebraic laws, idempotence).","development-setup#Development setup":"Clone the repository and create a local opam switch: git clone https://github.com/bilk-scheme/bilk.git cd bilk opam switch create . ocaml-variants.5.3.0+BER eval $(opam env) Install dependencies: opam install . --deps-only --with-test -y Build and test: dune build dune test","discussions#Discussions":"For questions, ideas, and general discussion: github.com/bilk-scheme/bilk/discussions","project-structure#Project structure":"bin/main.ml CLI entry point lib/ Core library (37 modules) test/ Test suite (40 files, 1600+ tests) stdlib/srfi/ Bundled SRFI library sources examples/ Example programs Each lib/ module has a corresponding test/test_.ml.","reporting-bugs#Reporting bugs":"Open an issue on GitHub: github.com/bilk-scheme/bilk/issues\nInclude:\nWhat you expected to happen What actually happened A minimal Scheme program that reproduces the issue Your platform (OS, OCaml version)","submitting-changes#Submitting changes":"Fork the repository on GitHub Create a feature branch from main Write tests, then implement Ensure dune test passes Open a pull request with a clear description"},"title":"Contributing"},"/docs/":{"data":{"":"Welcome to the Bilk Scheme documentation. Choose a section to get started.\nGetting StartedInstall Bilk Scheme, write your first program, and run it. Language GuideTutorial-style introduction to Scheme with Bilk Scheme. Tool GuideREPL, LSP, debugger, profiler, packages, and build system. SRFI ReferenceAll 36 bundled SRFIs with import forms and descriptions."},"title":"Documentation"},"/docs/getting-started/":{"data":{"":"This guide walks you through installing Bilk Scheme and writing your first Scheme program.","compiling-programs#Compiling programs":"Bilk Scheme can compile Scheme source ahead of time. There are two targets:\nFASL bytecode — a portable binary format:\nbilk compile hello.scm -o hello.fasl bilk run hello.fasl Standalone executable — a self-contained binary:\nbilk compile hello.scm --exe -o hello ./hello","editor-setup#Editor setup":"Bilk Scheme includes a Language Server Protocol (LSP) server that provides diagnostics, go-to-definition, find-references, hover, and completion.\nStart the LSP server with:\nbilk lsp Configure your editor to use bilk lsp as the language server command for Scheme files.\nVS CodeEmacsNeovim Install a generic LSP client extension (such as vscode-langservers or configure via .vscode/settings.json):\n{ \"languageServerExample.trace.server\": \"verbose\", \"[scheme]\": { \"editor.formatOnSave\": false } } Point the LSP client at bilk lsp as the server command for scheme files.\nUsing eglot (built into Emacs 29+):\n(add-to-list 'eglot-server-programs '(scheme-mode . (\"bilk\" \"lsp\"))) Then run M-x eglot in a Scheme buffer.\nUsing nvim-lspconfig:\nvim.lsp.config('bilk', { cmd = { 'bilk', 'lsp' }, filetypes = { 'scheme' }, root_markers = { '.git' }, }) vim.lsp.enable('bilk')","installation#Installation":"Clone the repository and create a local opam switch:\ngit clone https://github.com/bilk-scheme/bilk.git cd bilk opam switch create . ocaml-variants.5.3.0+BER eval $(opam env) Install dependencies:\nopam install . --deps-only --with-test -y Build and install:\ndune build dune install Verify the installation:\nbilk -e '(display \"ready\")' You should see ready printed to the terminal.","next-steps#Next steps":"You now have Bilk Scheme installed and know how to run, compile, and edit Scheme code. Explore the Guide for in-depth coverage of macros, the numeric tower, libraries, and developer tools.","prerequisites#Prerequisites":"Bilk Scheme requires:\nOCaml 5.3.0 with the BER MetaOCaml variant (ocaml-variants.5.3.0+BER) opam (the OCaml package manager) GMP (GNU Multiple Precision Arithmetic Library) Install GMP for your platform:\nDebian/UbuntumacOS sudo apt install libgmp-dev brew install gmp","running-a-file#Running a file":"Create a file called hello.scm:\n(import (scheme base) (scheme write)) (define (greet name) (display \"Hello, \") (display name) (display \"!\") (newline)) (greet \"world\") Run it:\nbilk hello.scm Hello, world! You can also evaluate a single expression from the command line:\nbilk -e '(for-each display (list 3 \"+\" 4 \"=\" (+ 3 4)))'","shebang-scripts#Shebang scripts":"Add a shebang line to make a Scheme file directly executable:\n#!/usr/bin/env bilk (import (scheme base) (scheme write) (scheme process-context)) (for-each (lambda (arg) (display arg) (newline)) (command-line)) chmod +x script.scm ./script.scm arg1 arg2","the-repl#The REPL":"Start the interactive REPL by running bilk with no arguments:\nbilk Try evaluating some expressions:\n\u003e (+ 1 2) 3 \u003e (define (square x) (* x x)) \u003e (square 12) 144 \u003e (map square '(1 2 3 4 5)) (1 4 9 16 25) The REPL supports syntax highlighting, rainbow parentheses, multi-line input, tab completion, and history. Type ,help to see available REPL commands, or ,paredit to toggle structural editing mode."},"title":"Getting Started"},"/docs/guide/":{"data":{"":"A tutorial-style introduction to Scheme programming with Bilk Scheme. Each chapter builds on the previous one and includes runnable examples.\nExpressions \u0026 ValuesAtoms, lists, evaluation, and basic types. Definitions \u0026 Functionsdefine, lambda, closures, and variadic functions. Data TypesPairs, lists, vectors, strings, hash tables, and more. Numeric TowerFixnums, bignums, rationals, flonums, and complex numbers. Control FlowConditionals, loops, recursion, and tail calls. RecordsUser-defined data types with define-record-type. MacrosHygienic macros with syntax-rules and define-syntax. LibrariesThe R7RS module system: define-library, import, export. Continuationscall/cc, dynamic-wind, and first-class control flow. I/O \u0026 PortsReading, writing, files, and string ports. Error Handlingguard, raise, and error objects."},"title":"Language Guide"},"/docs/guide/continuations/":{"data":{"":"Bilk Scheme supports first-class continuations via stack-copying call/cc.","callcc#call/cc":"call-with-current-continuation (abbreviated call/cc) captures the current point of execution as a procedure. Calling that procedure jumps back to the captured point:\n(call/cc (lambda (k) (k 42))) ; =\u003e 42 The continuation k represents “what would have happened next.” Calling (k 42) abandons the current computation and returns 42 to the caller of call/cc.","dynamic-wind#dynamic-wind":"dynamic-wind ensures that setup and cleanup code runs even when control flow is disrupted by continuations:\n(dynamic-wind (lambda () (display \"enter\\n\")) (lambda () (display \"body\\n\") 42) (lambda () (display \"exit\\n\"))) ; prints: ; enter ; body ; exit ; =\u003e 42 The three arguments are:\nbefore — called on entry (including re-entry via continuation) thunk — the main computation after — called on exit (including escape via continuation)","example-exception-like-behavior#Example: exception-like behavior":"Before Scheme had guard, call/cc was used for exception handling:\n(define (divide a b) (call/cc (lambda (escape) (when (zero? b) (escape \"division by zero\")) (/ a b)))) (divide 10 3) ; =\u003e 10/3 (divide 10 0) ; =\u003e \"division by zero\" For real error handling, use guard instead.","multiple-values#Multiple values":"call-with-values passes multiple return values between procedures:\n(call-with-values (lambda () (values 1 2 3)) (lambda (a b c) (+ a b c))) ; =\u003e 6 Use values to return multiple values and call-with-values to receive them.","non-local-exit#Non-local exit":"A common use is early return from a computation:\n(define (find-first pred lst) (call/cc (lambda (return) (for-each (lambda (x) (when (pred x) (return x))) lst) #f))) (find-first even? '(1 3 5 4 7)) ; =\u003e 4 (find-first even? '(1 3 5 7)) ; =\u003e #f"},"title":"Continuations"},"/docs/guide/control-flow/":{"data":{"":"","apply#apply":"apply calls a function with arguments from a list:\n(apply + '(1 2 3 4 5)) ; =\u003e 15 (apply max '(3 1 4 1 5)) ; =\u003e 5","case#case":"case compares a key against literal values using eqv?:\n(define (day-type day) (case day ((monday tuesday wednesday thursday friday) \"weekday\") ((saturday sunday) \"weekend\") (else \"unknown\"))) (day-type 'saturday) ; =\u003e \"weekend\"","cond#cond":"cond tests multiple conditions in order:\n(define (classify n) (cond ((negative? n) \"negative\") ((zero? n) \"zero\") ((positive? n) \"positive\"))) (classify -5) ; =\u003e \"negative\" (classify 0) ; =\u003e \"zero\" The =\u003e arrow syntax passes the test result to a procedure:\n(cond ((assv 'b '((a 1) (b 2) (c 3))) =\u003e cdr) (else #f)) ; =\u003e 2","conditionals#Conditionals":"","do#do":"do provides an explicit loop with initialization, step, and termination:\n(do ((i 0 (+ i 1)) (sum 0 (+ sum i))) ((\u003e i 100) sum)) ; =\u003e 5050 Each variable has an init value and a step expression. The loop terminates when the test evaluates to true, returning the result expression.","higher-order-iteration#Higher-order iteration":"map, for-each, and filter (from SRFI 1) apply a function to each element:\n(map square '(1 2 3 4 5)) ; =\u003e (1 4 9 16 25) (for-each display '(1 2 3)) ; prints: 123 (import (srfi 1)) (filter odd? '(1 2 3 4 5)) ; =\u003e (1 3 5)","if#if":"The basic conditional — evaluates one of two branches:\n(if (\u003e 3 2) \"yes\" \"no\") ; =\u003e \"yes\" (if #f \"yes\" \"no\") ; =\u003e \"no\" The else branch is optional:\n(if (\u003e 3 2) (display \"yes\")) ; prints \"yes\"","logical-operators#Logical operators":"and and or short-circuit and return the deciding value:\n(and 1 2 3) ; =\u003e 3 (and 1 #f 3) ; =\u003e #f (or #f #f 3) ; =\u003e 3 (or 1 2 3) ; =\u003e 1","named-let-loops#Named let loops":"Named let is the idiomatic looping construct:\n(let loop ((i 0) (sum 0)) (if (\u003e i 100) sum (loop (+ i 1) (+ sum i)))) ; =\u003e 5050","recursion#Recursion":"Recursion is the primary way to express iteration in Scheme:\n(define (factorial n) (if (\u003c= n 1) 1 (* n (factorial (- n 1))))) (factorial 10) ; =\u003e 3628800","tail-calls#Tail calls":"Bilk Scheme guarantees tail-call optimization. A call in tail position reuses the current stack frame, allowing unbounded recursion:\n(define (factorial n) (let loop ((i n) (acc 1)) (if (\u003c= i 1) acc (loop (- i 1) (* acc i))))) (factorial 100000) ; works — no stack overflow","when-and-unless#when and unless":"when executes a body only if the test is true:\n(when (\u003e 3 2) (display \"yes\") (newline)) unless is the negation:\n(unless (= x 0) (display (/ 1 x)))"},"title":"Control Flow"},"/docs/guide/data-types/":{"data":{"":"Bilk Scheme supports all R7RS data types plus extensions from bundled SRFIs.","booleans#Booleans":"#t ; true #f ; false (not #t) ; =\u003e #f (not #f) ; =\u003e #t (not 0) ; =\u003e #f (0 is truthy in Scheme)","bytevectors#Bytevectors":"Bytevectors hold raw bytes (unsigned 8-bit integers):\n(bytevector 1 2 3) ; =\u003e #u8(1 2 3) (make-bytevector 4 0) ; =\u003e #u8(0 0 0 0) (bytevector-u8-ref #u8(10 20) 1) ; =\u003e 20 (bytevector-length #u8(1 2 3)) ; =\u003e 3","character-sets#Character sets":"Character sets represent collections of characters (from SRFI 14):\n(import (srfi 14)) (char-set-contains? char-set:letter #\\a) ; =\u003e #t (char-set-contains? char-set:digit #\\5) ; =\u003e #t","characters#Characters":"Characters represent Unicode code points:\n#\\a ; lowercase a #\\space ; space character #\\newline ; newline (char-\u003einteger #\\A) ; =\u003e 65 (integer-\u003echar 955) ; =\u003e #\\λ (char-alphabetic? #\\a) ; =\u003e #t (char-upcase #\\a) ; =\u003e #\\A","hash-tables#Hash tables":"Hash tables provide key-value lookup (from SRFI 69):\n(import (srfi 69)) (define ht (make-hash-table)) (hash-table-set! ht 'name \"bilk\") (hash-table-set! ht 'version 1) (hash-table-ref ht 'name) ; =\u003e \"bilk\" (hash-table-exists? ht 'name) ; =\u003e #t (hash-table-keys ht) ; =\u003e (name version)","pairs-and-lists#Pairs and lists":"A pair holds two values — car and cdr:\n(cons 1 2) ; =\u003e (1 . 2) (car (cons 1 2)) ; =\u003e 1 (cdr (cons 1 2)) ; =\u003e 2 A proper list is a chain of pairs ending in '():\n(list 1 2 3) ; =\u003e (1 2 3) (cons 1 (cons 2 (cons 3 '()))) ; same thing Common list operations:\n(car '(a b c)) ; =\u003e a (cdr '(a b c)) ; =\u003e (b c) (length '(1 2 3)) ; =\u003e 3 (append '(1 2) '(3 4)) ; =\u003e (1 2 3 4) (reverse '(1 2 3)) ; =\u003e (3 2 1) (list-ref '(a b c) 1) ; =\u003e b","strings#Strings":"Strings are mutable sequences of characters:\n(string-length \"hello\") ; =\u003e 5 (string-ref \"hello\" 0) ; =\u003e #\\h (substring \"hello world\" 6 11) ; =\u003e \"world\" (string-append \"foo\" \"bar\") ; =\u003e \"foobar\" (string-upcase \"hello\") ; =\u003e \"HELLO\" (string-\u003elist \"abc\") ; =\u003e (#\\a #\\b #\\c) (list-\u003estring '(#\\h #\\i)) ; =\u003e \"hi\"","symbols#Symbols":"Symbols are interned identifiers, often used as keys:\n(symbol? 'hello) ; =\u003e #t (symbol-\u003estring 'hello) ; =\u003e \"hello\" (string-\u003esymbol \"world\") ; =\u003e world (eq? 'foo 'foo) ; =\u003e #t (same object)","the-empty-list-and-void#The empty list and void":"(null? '()) ; =\u003e #t (list? '()) ; =\u003e #t void is the return value of side-effecting forms like define, set!, and display. It is not printed in the REPL.","vectors#Vectors":"Vectors are fixed-size, mutable, indexed arrays:\n(vector 1 2 3) ; =\u003e #(1 2 3) (make-vector 5 0) ; =\u003e #(0 0 0 0 0) (vector-ref #(a b c) 1) ; =\u003e b (vector-length #(1 2 3)) ; =\u003e 3 (define v (vector 10 20 30)) (vector-set! v 1 99) v ; =\u003e #(10 99 30)"},"title":"Data Types"},"/docs/guide/definitions/":{"data":{"":"","begin#begin":"begin sequences multiple expressions, returning the value of the last:\n(begin (display \"hello\") (newline) 42) ; =\u003e 42 (after printing \"hello\\n\")","closures#Closures":"Functions close over their environment — they capture bindings from the scope where they were created:\n(define (make-adder n) (lambda (x) (+ n x))) (define add5 (make-adder 5)) (add5 10) ; =\u003e 15","functions#Functions":"Functions are defined with define and a parameter list:\n(define (square x) (* x x)) (square 5) ; =\u003e 25 This is shorthand for binding a lambda:\n(define square (lambda (x) (* x x)))","let#let":"let introduces parallel local bindings:\n(let ((x 1) (y 2)) (+ x y)) ; =\u003e 3 Bindings are evaluated in parallel — y cannot reference x:\n(let ((x 1) (y (+ x 1))) ; ERROR: x is not yet bound y)","let-1#let*":"let* evaluates bindings sequentially:\n(let* ((x 1) (y (+ x 1))) y) ; =\u003e 2","letrec#letrec":"letrec allows mutually recursive bindings:\n(letrec ((even? (lambda (n) (if (= n 0) #t (odd? (- n 1))))) (odd? (lambda (n) (if (= n 0) #f (even? (- n 1)))))) (even? 10)) ; =\u003e #t","local-bindings#Local bindings":"","multiple-parameters#Multiple parameters":"(define (add a b) (+ a b)) (add 3 4) ; =\u003e 7","named-let#Named let":"A let with a name creates a recursive loop:\n(let loop ((i 0)) (when (\u003c i 5) (display i) (display \" \") (loop (+ i 1)))) ; prints: 0 1 2 3 4 This is the idiomatic way to write loops in Scheme.","variables#Variables":"Bind a name with define:\n(define x 42) (define greeting \"hello\") (+ x 8) ; =\u003e 50 Mutate an existing binding with set!:\n(define counter 0) (set! counter (+ counter 1)) counter ; =\u003e 1","variadic-functions#Variadic functions":"A dotted parameter list captures extra arguments as a list:\n(define (first-and-rest first . rest) (list first rest)) (first-and-rest 1 2 3 4) ; =\u003e (1 (2 3 4)) A single symbol captures all arguments:\n(define (all-args . args) args) (all-args 1 2 3) ; =\u003e (1 2 3)"},"title":"Definitions \u0026 Functions"},"/docs/guide/errors/":{"data":{"":"Bilk Scheme provides R7RS exception handling with guard, raise, and error objects.","cleanup-with-dynamic-wind#Cleanup with dynamic-wind":"Combine guard with dynamic-wind to ensure resources are released:\n(define (with-file filename proc) (let ((port (open-input-file filename))) (dynamic-wind (lambda () #f) (lambda () (proc port)) (lambda () (close-input-port port))))) (guard (exn ((file-error? exn) \"file error\")) (with-file \"data.txt\" (lambda (port) (read-line port))))","error-objects#Error objects":"error creates structured error objects with a message and irritants:\n(guard (exn ((error-object? exn) (list (error-object-message exn) (error-object-irritants exn)))) (error \"bad value\" 42 \"expected positive\")) ; =\u003e (\"bad value\" (42 \"expected positive\")) Error object predicates:\n(error-object? exn) ; is it an error object? (error-object-message exn) ; the message string (error-object-irritants exn) ; list of extra values (file-error? exn) ; was it a file-related error? (read-error? exn) ; was it a read/parse error?","guard#guard":"guard catches exceptions with cond-like clauses:\n(guard (exn ((string? exn) (string-append \"caught: \" exn)) ((error-object? exn) (error-object-message exn))) (error \"file not found\" \"data.txt\")) ; =\u003e \"file not found\" The variable exn is bound to the raised value. Each clause tests a condition; the first matching clause handles the exception. If no clause matches, the exception is re-raised.","guarding-specific-errors#Guarding specific errors":"(define (safe-divide a b) (guard (exn ((error-object? exn) #f)) (/ a b))) (safe-divide 10 3) ; =\u003e 10/3 (safe-divide 10 0) ; =\u003e #f","raising-errors#Raising errors":"Use error to signal an error with a message and optional irritant values:\n(error \"division by zero\") (error \"index out of range\" 'vector-ref 10) Use raise to throw any value as an exception:\n(raise \"something went wrong\") (raise (list 'my-error 42))","re-raising#Re-raising":"If no clause matches in guard, the exception propagates to the next handler. You can also explicitly re-raise:\n(guard (exn ((file-error? exn) (display \"file error handled\\n\")) (else (raise exn))) ; re-raise anything else (error \"not a file error\")) ; raises \"not a file error\" to the outer handler"},"title":"Error Handling"},"/docs/guide/expressions/":{"data":{"":"Scheme programs are made of expressions. Every expression evaluates to a value.","atoms#Atoms":"The simplest expressions are literal values — atoms:\n42 ; fixnum (integer) 3.14 ; flonum (floating-point) #t ; boolean true #f ; boolean false \"hello\" ; string #\\a ; character 'foo ; symbol","equality#Equality":"Scheme has three equality predicates with different semantics:\n(eq? 'a 'a) ; =\u003e #t (identity — same object) (eqv? 42 42) ; =\u003e #t (equivalence — same value for simple types) (equal? '(1 2) '(1 2)) ; =\u003e #t (structural — deep comparison) Use equal? when in doubt. Use eq? or eqv? when you need to distinguish identity from structural equality.","evaluation#Evaluation":"An unquoted list is a function call. The first element is the operator and the rest are arguments:\n(+ 1 2) ; =\u003e 3 (* 3 4) ; =\u003e 12 (string-length \"hi\") ; =\u003e 2 (list 1 2 3) ; =\u003e (1 2 3) Use quote (or the ' shorthand) to prevent evaluation:\n(quote (+ 1 2)) ; =\u003e (+ 1 2) — a list, not 3 '(+ 1 2) ; same thing","lists-and-s-expressions#Lists and S-expressions":"Scheme code and data share the same syntax: the S-expression. A list is written with parentheses:\n'(1 2 3) ; a list of three numbers '(a b c) ; a list of three symbols '(1 \"two\" #t) ; lists can contain mixed types '() ; the empty list","nesting#Nesting":"Expressions nest naturally:\n(+ (* 2 3) (- 10 4)) ; =\u003e 12 (string-append \"hello\" \" \" \"world\") ; =\u003e \"hello world\"","truthiness#Truthiness":"In Scheme, only #f is false. Everything else — including 0, \"\", and '() — is true:\n(if 0 \"true\" \"false\") ; =\u003e \"true\" (if \"\" \"true\" \"false\") ; =\u003e \"true\" (if '() \"true\" \"false\") ; =\u003e \"true\" (if #f \"true\" \"false\") ; =\u003e \"false\"","type-predicates#Type predicates":"Every type has a predicate that tests membership:\n(number? 42) ; =\u003e #t (string? \"hi\") ; =\u003e #t (boolean? #f) ; =\u003e #t (symbol? 'foo) ; =\u003e #t (char? #\\a) ; =\u003e #t (pair? '(1 2)) ; =\u003e #t (null? '()) ; =\u003e #t (procedure? +) ; =\u003e #t"},"title":"Expressions \u0026 Values"},"/docs/guide/io/":{"data":{"":"Bilk Scheme uses the R7RS port model for input and output. Ports represent streams of characters or bytes.","binary-io#Binary I/O":"Read and write raw bytes with bytevector ports:\n(read-u8) ; read one byte (peek-u8) ; look ahead one byte (write-u8 65) ; write byte 65 (ASCII 'A') (read-bytevector 10 port) ; read 10 bytes (write-bytevector bv port) ; write bytevector","end-of-file#End of file":"All read operations return an EOF object when the input is exhausted:\n(let ((ch (read-char port))) (if (eof-object? ch) (display \"done\") (begin (write-char ch) (loop))))","file-io#File I/O":"Open files explicitly:\n(define in (open-input-file \"data.txt\")) (define line (read-line in)) (close-input-port in) (define out (open-output-file \"output.txt\")) (display \"hello\" out) (close-output-port out) Or use the convenience wrappers that handle closing automatically:\n(call-with-input-file \"data.txt\" (lambda (port) (read-line port))) (call-with-output-file \"output.txt\" (lambda (port) (display \"hello\" port)))","flushing#Flushing":"Output may be buffered. Force it to the underlying stream with:\n(flush-output-port) (flush-output-port (current-error-port))","input#Input":"(read-char) ; read one character (or eof-object) (peek-char) ; look ahead without consuming (read-line) ; read until newline (read-string 5) ; read exactly 5 characters (read) ; read a Scheme datum (char-ready?) ; check if input is available","output#Output":"(display \"hello\") ; write in human-readable form (write \"hello\") ; write in Scheme notation: \"hello\" (newline) ; write a newline (write-char #\\a) ; write a single character (write-string \"hello\") ; write a string display omits quotes on strings and backslashes on characters. write produces output that read can parse back.","reading-all-lines#Reading all lines":"A common pattern for processing a file line by line:\n(call-with-input-file \"data.txt\" (lambda (port) (let loop ((line (read-line port))) (unless (eof-object? line) (display line) (newline) (loop (read-line port))))))","redirecting-standard-ports#Redirecting standard ports":"Temporarily rebind the current input or output port:\n(with-input-from-file \"data.txt\" (lambda () (read-line))) ; reads from data.txt (with-output-to-file \"output.txt\" (lambda () (display \"hello\"))) ; writes to output.txt","standard-ports#Standard ports":"Three ports are open by default:\n(current-input-port) ; stdin (current-output-port) ; stdout (current-error-port) ; stderr","string-ports#String ports":"Read from or write to in-memory strings:\n(define in (open-input-string \"(+ 1 2)\")) (read in) ; =\u003e (+ 1 2) (define out (open-output-string)) (display 42 out) (display \" hello\" out) (get-output-string out) ; =\u003e \"42 hello\""},"title":"I/O \u0026 Ports"},"/docs/guide/libraries/":{"data":{"":"Bilk Scheme implements the R7RS library system for organizing code into reusable modules.","cond-expand#cond-expand":"Use cond-expand to conditionally include code based on available features:\n(define-library (mylib compat) (import (scheme base)) (cond-expand (bilk (begin (define (impl) \"bilk\"))) (else (begin (define (impl) \"other\")))) (export impl))","define-library#define-library":"A library has a name, imports, exports, and a body:\n(define-library (mylib math) (import (scheme base)) (export square cube) (begin (define (square x) (* x x)) (define (cube x) (* x x x)))) Library names are lists of identifiers, e.g. (mylib math).","excluding#Excluding":"Import everything except specific bindings:\n(import (except (scheme base) define))","export#export":"The export declaration lists which bindings are visible to importers:\n(export square cube) ; export by name (export (rename internal-name external-name)) ; export with renaming","import#import":"Import a library to use its exports:\n(import (mylib math)) (square 5) ; =\u003e 25 (cube 3) ; =\u003e 27","include#include":"Include external source files into a library body:\n(define-library (mylib utils) (import (scheme base)) (export helper) (include \"utils-impl.scm\"))","library-file-conventions#Library file conventions":"Library source files use the .sld extension and are discovered automatically. A library named (foo bar) is found at foo/bar.sld on the library search path.","prefix#Prefix":"Add a prefix to all imported names:\n(import (prefix (mylib math) m:)) (m:square 5) ; =\u003e 25","renaming#Renaming":"Rename imports to avoid conflicts:\n(import (rename (mylib math) (square sq))) (sq 5) ; =\u003e 25","selective-import#Selective import":"Import only specific bindings:\n(import (only (scheme base) define if +))","standard-libraries#Standard libraries":"Bilk Scheme provides all 16 R7RS standard libraries:\nLibrary Purpose (scheme base) Core forms and procedures (scheme case-lambda) case-lambda form (scheme char) Character operations (scheme complex) Complex number operations (scheme cxr) caaar through cddddr (scheme eval) eval and environment (scheme file) File I/O (scheme inexact) Inexact number operations (scheme lazy) delay, force, promises (scheme load) load (scheme process-context) command-line, exit, environment (scheme read) read (scheme repl) interaction-environment (scheme time) current-second, current-jiffy (scheme write) display, write (scheme r5rs) R5RS compatibility"},"title":"Libraries"},"/docs/guide/macros/":{"data":{"":"Bilk Scheme supports hygienic macros via syntax-rules. Macros transform code at compile time without the accidental-capture bugs of traditional Lisp macros.","assert#Assert":"(define-syntax assert (syntax-rules () ((assert expr) (unless expr (error \"assertion failed\" 'expr)))))","common-patterns#Common patterns":"","define-syntax#define-syntax":"Define a macro with define-syntax and syntax-rules:\n(define-syntax my-when (syntax-rules () ((my-when test body ...) (if test (begin body ...))))) (my-when #t (display \"hello\") (newline)) ; prints: hello The first argument to syntax-rules is a list of literal identifiers (often empty). The remaining forms are pattern/template pairs.","hygiene#Hygiene":"Bilk Scheme’s macros are hygienic: bindings introduced by a macro cannot conflict with bindings at the use site.\n(define-syntax swap! (syntax-rules () ((swap! a b) (let ((tmp a)) (set! a b) (set! b tmp))))) (define tmp 99) (define x 1) (define y 2) (swap! x y) x ; =\u003e 2 y ; =\u003e 1 tmp ; =\u003e 99 (not affected — hygiene protects it) The tmp inside the macro expansion is distinct from the tmp at the call site.","let-syntax-and-letrec-syntax#let-syntax and letrec-syntax":"For macros with limited scope:\n(let-syntax ((double (syntax-rules () ((double x) (+ x x))))) (double 21)) ; =\u003e 42 ; double is not visible here letrec-syntax allows the macros to reference each other.","literal-keywords#Literal keywords":"The literals list specifies identifiers that must match literally rather than acting as pattern variables:\n(define-syntax my-cond (syntax-rules (else) ((my-cond (else body ...)) (begin body ...)) ((my-cond (test body ...) clause ...) (if test (begin body ...) (my-cond clause ...))))) Here else is a literal — it matches only the identifier else, not an arbitrary expression.","multiple-rules#Multiple rules":"A macro can have several patterns, tried in order:\n(define-syntax my-and (syntax-rules () ((my-and) #t) ((my-and x) x) ((my-and x y ...) (if x (my-and y ...) #f)))) (my-and 1 2 3) ; =\u003e 3 (my-and 1 #f 3) ; =\u003e #f","pattern-matching#Pattern matching":"Patterns match against the input syntax. ... (ellipsis) matches zero or more repetitions:\n(define-syntax my-list (syntax-rules () ((my-list) '()) ((my-list x ...) (list x ...)))) (my-list 1 2 3) ; =\u003e (1 2 3)","swap#Swap":"(define-syntax swap! (syntax-rules () ((swap! a b) (let ((tmp a)) (set! a b) (set! b tmp)))))","while-loop#While loop":"(define-syntax while (syntax-rules () ((while test body ...) (let loop () (when test body ... (loop))))))"},"title":"Macros"},"/docs/guide/numeric-tower/":{"data":{"":"Bilk Scheme implements the full R7RS numeric tower. Numbers are automatically promoted to wider types as needed.","arbitrary-precision#Arbitrary precision":"Bignums grow without overflow:\n(expt 2 100) ; =\u003e 1267650600228229401496703205376 (+ (expt 10 50) 1) ; =\u003e 100000000000000000000000000000000000000000000000000001 When a bignum fits in a machine word, it is automatically stored as a fixnum.","automatic-promotion#Automatic promotion":"When an operation mixes numeric types, the result is promoted to the wider type:\n(+ 1 1/2) ; =\u003e 3/2 (fixnum + rational → rational) (+ 1 2.0) ; =\u003e 3.0 (fixnum + flonum → flonum) (+ 1 1+2i) ; =\u003e 2+2i (fixnum + complex → complex) (* 1/2 3) ; =\u003e 3/2 (rational × fixnum → rational) (+ 1/2 0.5) ; =\u003e 1.0 (rational + flonum → flonum)","complex-numbers#Complex numbers":"Complex numbers are written as a+bi:\n3+4i ; complex literal (make-rectangular 3 4) ; same thing (+ 1+2i 3+4i) ; =\u003e 4+6i (* 0+1i 0+1i) ; =\u003e -1 (i² = -1) (magnitude 3+4i) ; =\u003e 5.0 (angle 0+1i) ; =\u003e 1.5707963267948966 (real-part 3+4i) ; =\u003e 3 (imag-part 3+4i) ; =\u003e 4","exact-vs-inexact#Exact vs. inexact":"Fixnums, bignums, and rationals are exact. Flonums are inexact. Complex numbers can be either, depending on their components.\n(exact? 1/3) ; =\u003e #t (inexact? 3.14) ; =\u003e #t (exact-\u003einexact 1/3) ; =\u003e 0.3333333333333333 (inexact-\u003eexact 0.5) ; =\u003e 1/2 Integer division produces exact rationals, not truncated integers:\n(/ 1 3) ; =\u003e 1/3 (not 0 or 0.333...) (/ 22 7) ; =\u003e 22/7","math-functions#Math functions":"(abs -5) ; =\u003e 5 (min 3 1 4) ; =\u003e 1 (max 3 1 4) ; =\u003e 4 (gcd 12 8) ; =\u003e 4 (lcm 4 6) ; =\u003e 12 (floor 3.7) ; =\u003e 3.0 (ceiling 3.2) ; =\u003e 4.0 (round 3.5) ; =\u003e 4.0 (truncate 3.7) ; =\u003e 3.0 (sqrt 16) ; =\u003e 4 (expt 2 10) ; =\u003e 1024 Trigonometric and transcendental functions:\n(sin 0) ; =\u003e 0 (cos 0) ; =\u003e 1 (exp 1) ; =\u003e 2.718281828459045 (log 1) ; =\u003e 0 (atan 1 1) ; =\u003e 0.7853981633974483","numeric-predicates#Numeric predicates":"(number? 42) ; =\u003e #t (integer? 1) ; =\u003e #t (rational? 1/3) ; =\u003e #t (real? 3.14) ; =\u003e #t (complex? 1+2i) ; =\u003e #t (exact? 1/3) ; =\u003e #t (inexact? 1.0) ; =\u003e #t (zero? 0) ; =\u003e #t (positive? 5) ; =\u003e #t (negative? -3) ; =\u003e #t (finite? 1.0) ; =\u003e #t (infinite? +inf.0) ; =\u003e #t (nan? +nan.0) ; =\u003e #t","rational-arithmetic#Rational arithmetic":"Rationals are always in lowest terms:\n(+ 1/2 1/3) ; =\u003e 5/6 (- 1/2 1/3) ; =\u003e 1/6 (* 2/3 3/4) ; =\u003e 1/2 (/ 3/4 2/3) ; =\u003e 9/8 (numerator 5/6) ; =\u003e 5 (denominator 5/6) ; =\u003e 6","the-five-numeric-types#The five numeric types":"From narrowest to widest:\nType Description Examples Fixnum Machine-word integers 0, 42, -7 Bignum Arbitrary-precision integers (GMP) (expt 2 100) Rational Exact fractions 1/3, 22/7 Flonum IEEE 754 double-precision 3.14, 1e10 Complex Real + imaginary 3+4i, 0+1i"},"title":"Numeric Tower"},"/docs/guide/records/":{"data":{"":"Records let you define new data types with named fields.","define-record-type#define-record-type":"(define-record-type (make-point x y) point? (x point-x) (y point-y)) This defines:\nmake-point — constructor point? — type predicate point-x, point-y — field accessors (define p (make-point 3 4)) (point? p) ; =\u003e #t (point-x p) ; =\u003e 3 (point-y p) ; =\u003e 4","example-binary-tree#Example: binary tree":"(define-record-type (make-tree value left right) tree? (value tree-value) (left tree-left) (right tree-right)) (define (tree-member? x t) (cond ((not (tree? t)) #f) ((= x (tree-value t)) #t) ((\u003c x (tree-value t)) (tree-member? x (tree-left t))) (else (tree-member? x (tree-right t))))) (define t (make-tree 5 (make-tree 3 #f #f) (make-tree 7 #f #f))) (tree-member? 3 t) ; =\u003e #t (tree-member? 6 t) ; =\u003e #f","mutable-fields#Mutable fields":"Add a mutator by including a third element in the field spec:\n(define-record-type (make-counter value) counter? (value counter-value set-counter-value!)) (define c (make-counter 0)) (set-counter-value! c 42) (counter-value c) ; =\u003e 42 Fields without a mutator are immutable.","partial-constructors#Partial constructors":"The constructor only needs to list the fields it initializes. Other fields can be set via mutators:\n(define-record-type (make-person name) person? (name person-name) (age person-age set-person-age!))"},"title":"Records"},"/docs/srfi/":{"data":{"":"Bilk Scheme bundles 36 SRFIs (Scheme Requests for Implementation). Import them with (import (srfi N)).","built-in-srfis#Built-in SRFIs":"These SRFIs are implemented as native primitives for performance:\nSRFI Title Import 1 List Library (import (srfi 1)) 13 String Libraries (import (srfi 13)) 14 Character-set Library (import (srfi 14)) 69 Basic Hash Tables (import (srfi 69)) 115 Scheme Regular Expressions (import (srfi 115)) 151 Bitwise Operations (import (srfi 151))","library-srfis#Library SRFIs":"These SRFIs are implemented in Scheme and loaded from .sld files:\nSRFI Title Import 2 AND-LET*: an AND with local bindings (import (srfi 2)) 8 receive: Binding to formals of values (import (srfi 8)) 11 Syntax for receiving multiple values (import (srfi 11)) 16 Syntax for procedures of variable arity (import (srfi 16)) 26 Notation for specializing parameters (import (srfi 26)) 28 Basic format strings (import (srfi 28)) 31 A special form rec for recursive evaluation (import (srfi 31)) 41 Streams (import (srfi 41)) 48 Intermediate format strings (import (srfi 48)) 111 Boxes (import (srfi 111)) 113 Sets and Bags (import (srfi 113)) 117 Queues based on lists (import (srfi 117)) 125 Intermediate hash tables (import (srfi 125)) 128 Comparators (import (srfi 128)) 132 Sort Libraries (import (srfi 132)) 133 Vector Library (R7RS-compatible) (import (srfi 133)) 145 Assumptions (import (srfi 145)) 156 Syntactic combiners for binary predicates (import (srfi 156)) 158 Generators and Accumulators (import (srfi 158)) 162 Comparators sublibrary (import (srfi 162)) 175 ASCII character library (import (srfi 175)) 189 Maybe and Either (import (srfi 189)) 195 Multiple-value boxes (import (srfi 195)) 210 Procedures and syntax for multiple values (import (srfi 210)) 214 Flexvectors (import (srfi 214)) 219 Define higher-order lambda (import (srfi 219)) 223 Generalized binary search procedures (import (srfi 223)) 228 Composing comparators (import (srfi 228)) 234 Topological sorting (import (srfi 234)) 235 Combinators (import (srfi 235))","usage-example#Usage example":"(import (srfi 1) ; list library (srfi 13) ; string library (srfi 69)) ; hash tables ;; SRFI 1: list operations (iota 5) ; =\u003e (0 1 2 3 4) (zip '(a b c) '(1 2 3)) ; =\u003e ((a 1) (b 2) (c 3)) (partition even? '(1 2 3 4 5)) ; =\u003e (2 4) (1 3 5) ;; SRFI 13: string operations (string-join '(\"hello\" \"world\") \" \") ; =\u003e \"hello world\" (string-contains \"hello world\" \"world\") ; =\u003e 6 (string-trim-both \" hello \") ; =\u003e \"hello\" ;; SRFI 69: hash tables (define ht (make-hash-table)) (hash-table-set! ht 'x 42) (hash-table-ref ht 'x) ; =\u003e 42"},"title":"SRFI Reference"},"/docs/tools/":{"data":{"":"Bilk Scheme ships with a complete developer toolchain. Each tool is a subcommand of the bilk binary.\nREPLInteractive development with syntax highlighting and paredit. LSP ServerEditor integration via the Language Server Protocol. DebuggerStep-through debugging via the Debug Adapter Protocol. ProfilerRuntime profiling with flame graph output. Package ManagerInstall, manage, and publish Scheme packages. Build SystemCompile libraries, manage dependencies, and watch for changes."},"title":"Tool Guide"},"/docs/tools/build/":{"data":{"":"Bilk Scheme includes a build system that compiles libraries, manages dependencies, and watches for changes.","ahead-of-time-compilation#Ahead-of-time compilation":"For standalone programs (not libraries), use bilk compile:\nbilk compile program.scm -o program.fasl # bytecode bilk compile program.scm --exe -o program # native executable See Getting Started — Compiling programs for details.","commands#Commands":"bilk build # build all project libraries bilk build --clean # remove all .fasl cache files bilk build --dry-run # show what would be built bilk build --verbose # verbose output bilk build --watch # rebuild on source changes (Ctrl-C to stop) bilk build --graph # emit Graphviz DOT dependency graph","dependency-graph#Dependency graph":"Visualize library dependencies as a Graphviz DOT graph:\nbilk build --graph | dot -Tsvg -o deps.svg","fasl-caching#FASL caching":"Compiled libraries are cached as .fasl files alongside their .sld sources. Cache invalidation is mtime-based: if the source or any dependency is newer than the .fasl, the library is recompiled.","how-it-works#How it works":"The build system:\nAuto-discovers all .sld library files in the project Resolves inter-library dependencies Detects staleness (missing .fasl, source newer than cache, dependency changed) Compiles stale libraries to .fasl bytecode Caches the results for fast subsequent loads","testing#Testing":"Bilk Scheme also includes a test runner:\nbilk test # discover and run all tests bilk test --verbose # print file names during execution bilk test test/foo.scm # run a specific test file The test runner auto-discovers files matching test-*.scm or *-test.scm in the test/ directory, builds project libraries first, then runs each test as an isolated subprocess.","watch-mode#Watch mode":"bilk build --watch Monitors source directories for changes and automatically rebuilds stale libraries. When used alongside the REPL, rebuilt libraries are reloaded automatically."},"title":"Build System"},"/docs/tools/debugger/":{"data":{"":"Bilk Scheme includes a Debug Adapter Protocol (DAP) server for step-through debugging.","breakpoints#Breakpoints":"Set breakpoints at specific line numbers. Breakpoints are verified when first encountered during execution.","editor-integration#Editor integration":"Any DAP-compatible editor can connect to the Bilk Scheme debugger:\nVS Code — use a generic DAP extension or configure launch.json Emacs — use dape Neovim — use nvim-dap Configure the debug adapter to run bilk debug as the launch command.","expression-evaluation#Expression evaluation":"Evaluate arbitrary Scheme expressions in the context of any stack frame or the global environment.","features#Features":"","stack-inspection#Stack inspection":"View the full call stack with procedure name, file, line, and column for each frame.","starting-a-debug-session#Starting a debug session":"bilk debug program.scm By default the DAP server communicates over stdin/stdout. To use a TCP socket:\nbilk debug program.scm --port 5008","stepping#Stepping":"Mode Description Step in Stop at the next call, descending into functions Step over Stop at the next call at the same or lower depth Step out Stop when returning to the caller Continue Resume execution until the next breakpoint Pause Break at the next call site","variable-inspection#Variable inspection":"Inspect local and global variables in each stack frame. Composite values (pairs, vectors, records) can be expanded for hierarchical inspection."},"title":"Debugger"},"/docs/tools/lsp/":{"data":{"":"Bilk Scheme includes a Language Server Protocol (LSP) server for editor integration.","capabilities#Capabilities":"Feature Description Diagnostics Real-time compilation and macro-expansion errors as you type Hover Shows binding type (variable, core form, macro, unbound) Completion Symbol name completion with kind classification Go to definition Jump to the binding site of any identifier Find references Locate all uses of a binding Document symbols List all top-level definitions in the current file Semantic tokens Full semantic highlighting (keywords, strings, numbers, comments, variables, functions, parameters)","editor-configuration#Editor configuration":"See Getting Started — Editor setup for VS Code, Emacs, and Neovim configuration examples.\nThe key is to point your editor’s LSP client at bilk lsp as the server command for Scheme files.","how-it-works#How it works":"The LSP server performs a full recompilation on each document change. This gives accurate diagnostics for syntax errors, undefined variables, arity mismatches, and macro expansion failures.\nSemantic tokens classify every token in the file, enabling editors to provide richer highlighting than regex-based grammars. Token types include:\nkeyword — special forms (define, if, lambda, etc.) function — procedure references parameter — function parameters variable — other bindings string, number, comment — literals Token modifiers include definition (for binding sites) and readonly (for immutable bindings).","starting-the-server#Starting the server":"bilk lsp By default the server communicates over stdin/stdout. To use a TCP socket:\nbilk lsp --port 5007"},"title":"LSP Server"},"/docs/tools/packages/":{"data":{"":"Bilk Scheme includes a local package manager for installing and managing Scheme libraries.","commands#Commands":"Command Description bilk pkg init [NAME] Initialize a new project with package.scm (default name: current directory) bilk pkg install [PATH] Install a package from a directory (default: .) bilk pkg list List all installed packages and versions bilk pkg info [version] Show package details bilk pkg remove Remove a specific package version bilk pkg lock Resolve dependencies and write a lockfile bilk pkg why Explain why a package is in the dependency tree bilk pkg fetch [version] Download a package from a repository bilk pkg search Search repositories for packages","dependency-resolution#Dependency resolution":"When a package declares dependencies, Bilk Scheme resolves them using semantic versioning. The resolver picks the latest installed version that satisfies each constraint and detects circular dependencies.","environment-variables#Environment variables":"Variable Description BILK_HOME Override for Bilk Scheme home directory (default: ~/.bilk/) BILK_PATH Additional library search directories (colon-separated) BILK_VENV Path to active virtual environment","installing-a-package#Installing a package":"From the package directory:\nbilk pkg install Or from another location:\nbilk pkg install /path/to/package Packages are installed to ~/.bilk/packages///.","package-descriptor#Package descriptor":"Every package has a package.scm file in its root directory:\n((name \"my-package\") (version \"1.0.0\") (description \"A useful library\") (license \"MIT\") (depends ((name \"other-package\") (version \"\u003e=0.5.0\"))) (libraries ((name (mylib utils)) (path \"src/utils.sld\"))))","repository-management#Repository management":"Repositories are remote sources of packages. Manage them with bilk pkg repo:\nCommand Description bilk pkg repo add Add a package repository bilk pkg repo list List configured repositories bilk pkg repo remove Remove a repository bilk pkg repo update Update a repository’s package index","virtual-environments#Virtual environments":"Virtual environments isolate project-specific libraries:\nbilk venv myenv This creates a directory with a lib/ folder for local libraries and a bilk-venv.cfg marker file.\nActivate a virtual environment by setting:\nexport BILK_VENV=./myenv When activated, the lib/ directory is prepended to the library search path, so libraries installed there take precedence over system-wide packages."},"title":"Package Manager"},"/docs/tools/profiler/":{"data":{"":"Bilk Scheme includes a runtime profiler that instruments function calls and produces reports in multiple formats.","chrome-trace#Chrome trace":"bilk profile program.scm --format trace \u003e profile.json Produces Chrome Trace Event JSON format. Load it in chrome://tracing or Perfetto for time-series analysis.","flame-graph#Flame graph":"bilk profile program.scm --format flamegraph \u003e profile.svg Produces a self-contained SVG with embedded JavaScript for interactive exploration. Open it in a browser to click and zoom into hot call stacks.","metrics#Metrics":"For each procedure, the profiler tracks:\nMetric Description call_count Number of invocations total_time Wall-clock seconds including time in callees self_time Wall-clock seconds excluding time in callees","output-formats#Output formats":"Specify the format with --format:","running-the-profiler#Running the profiler":"bilk profile program.scm","text-default#Text (default)":"bilk profile program.scm --format text Prints a flat table to stderr sorted by self-time, with columns for self%, total time, self time, call count, procedure name, and source location.","typical-workflow#Typical workflow":"Run with --format text to identify the hottest procedures Generate a flame graph to understand call-stack context Optimize the hot path Re-profile to confirm the improvement"},"title":"Profiler"},"/docs/tools/repl/":{"data":{"":"Start the REPL by running bilk with no arguments:\nbilk","features#Features":"Syntax highlighting with two built-in themes (dark and light) Rainbow parentheses — depth-based color cycling for matching parens Paredit — structural editing that keeps parentheses balanced Multi-line input — automatic detection of incomplete expressions Tab completion — completes Scheme identifiers and REPL commands History — persistent across sessions, saved to ~/.bilk_history Emacs keybindings — Ctrl-A/E, Ctrl-B/F, Ctrl-K, Ctrl-U, Alt-Left/Right Library watching — in package projects, rebuilds stale libraries in the background","keyboard-shortcuts#Keyboard shortcuts":"Key Action Ctrl-A Move to start of line Ctrl-E Move to end of line Ctrl-B / Ctrl-F Move backward/forward one character Alt-Left / Alt-Right Move backward/forward one word Ctrl-K Kill from cursor to end of line Ctrl-U Kill from cursor to start of line Ctrl-W Kill previous word Up / Down Navigate history Tab Complete identifier or command Ctrl-D Exit (on empty line)","paredit-mode#Paredit mode":"Paredit keeps parentheses balanced automatically. When enabled:\nTyping ( inserts () and places the cursor inside Typing ) moves past the closing paren instead of inserting Backspace will not delete an unmatched paren \" handles string delimiters in balanced pairs Structural operations:\nOperation Description Slurp forward Absorb the next s-expression into the current list Slurp backward Absorb the previous s-expression Barf forward Eject the last s-expression from the current list Barf backward Eject the first s-expression Wrap Wrap the next s-expression in parentheses Splice Remove the enclosing parentheses Raise Replace the enclosing list with the current s-expression Toggle paredit on or off with ,paredit.","repl-commands#REPL commands":"Commands are prefixed with a comma:\nCommand Description ,help / ,h Show available commands ,quit / ,q Exit the REPL ,load Load and evaluate a Scheme file ,env List all bound names in the global environment ,libs List loaded/registered libraries ,available List all discoverable libraries on disk ,exports Show exports of a library, e.g. ,exports (scheme base) ,deps Show dependency tree, e.g. ,deps (srfi 1) ,reload Reload a library from source ,build Trigger library rebuild ,theme Switch theme: dark, light, none, or a file path ,paredit Toggle structural editing mode","themes#Themes":"Switch between built-in themes or load a custom theme file:\n,theme dark ,theme light ,theme none ,theme /path/to/my-theme.scm You can also set the default theme with the BILK_THEME environment variable.\nSettings (theme, paredit mode) persist across sessions in ~/.bilk/config."},"title":"REPL"},"/releases/":{"data":{"":"Bilk Scheme is under active development. No versioned releases have been published yet.","building-from-source#Building from source":"To use Bilk Scheme today, build from the main branch:\ngit clone https://github.com/bilk-scheme/bilk.git cd bilk opam switch create . ocaml-variants.5.3.0+BER eval $(opam env) opam install . --deps-only --with-test -y dune build dune install See Getting Started for detailed instructions.","following-development#Following development":"Source: github.com/bilk-scheme/bilk Discussions: github.com/bilk-scheme/bilk/discussions This page will be updated when versioned releases are available."},"title":"Releases"}}